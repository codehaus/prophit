<html><!-- #BeginTemplate "/Templates/prophit-general.dwt" -->
<head>
<!-- #BeginEditable "doctitle" --> 
<title>Product Plan</title>
<!-- #EndEditable --> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="keywords" content="java profile profiler hprof prof swing free gl4java opengl visualization visualizer cpu function time">
<script language="JavaScript">
<!--
function MM_reloadPage(init) {  //reloads the window if Nav4 resized
  if (init==true) with (navigator) {if ((appName=="Netscape")&&(parseInt(appVersion)==4)) {
    document.MM_pgW=innerWidth; document.MM_pgH=innerHeight; onresize=MM_reloadPage; }}
  else if (innerWidth!=document.MM_pgW || innerHeight!=document.MM_pgH) location.reload();
}
MM_reloadPage(true);
// -->
</script>
<link rel="stylesheet" href="default.css" type="text/css">
<STYLE>
	#topMenuLayer {border: solid; background-color: #dddddd; border-bottom-width: 1px; border-top-width: 1px; border-left-width: 1px; border-right-width: 1px; border-color: #FFFFFF #AAAAAA #AAAAAA #AAAAAA}
	#HeadingLayer {border: solid; border-bottom-width: 1px; border-top-width: 1px; border-left-width: 1px; border-right-width: 1px; border-color: #AAAAAA #AAAAAA #AAAAAA #AAAAAA}
	#leftcol {border: solid; background-color: #eeeeee; border-bottom-width: 1px; border-top-width: 1px; border-left-width: 1px; border-right-width: 1px; border-color: #FFFFFF #AAAAAA #AAAAAA #AAAAAA}
	.TopMenu {font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 12px; font-variant: small-caps}
	A:link {color: blue}
	A:hover {color: red! important}
	A:active {color: red! important}
	#topMenuLayer A {text-decoration: none}
	#leftcol A {text-decoration: none}
	DIV.header {border: solid; border-bottom-width: 1px; border-top-width: 1px; border-left-width: 1px; border-right-width: 1px; border-color: #AAAAAA #AAAAAA #AAAAAA #AAAAAA; background-color: #EBDEA9; font-family: Arial, Helvetica, sans serif; font-size: small; color: #333333; font-variant: small-caps; font-weight: bold }
	DIV.docnav {border: solid; border-bottom-width: 0px; border-top-width: 1px; border-left-width: 0px; border-right-width: 0px; border-color: #AAAAAA #AAAAAA #AAAAAA #AAAAAA; font-family: Arial, Helvetica, sans serif; font-size: small; color: #333333; font-variant: small-caps; font-weight: normal }
	.news {font-size: small; font-family: "Courier New" }
	TD.FAQH { font-color: #333333; font-weight: bold; background-color: #EEEEEE}
	TD.FAQ {border: solid; border-bottom-width: 1px; border-top-width: 1px; border-left-width: 1px; border-right-width: 1px; border-color: #AAAAAA #AAAAAA #AAAAAA #AAAAAA; font-size: x-small; font-color: #666666;  }
	DIV.FAQ {border: solid; border-bottom-width: 1px; border-top-width: 1px; border-left-width: 1px; border-right-width: 1px; border-color: #AAAAAA #AAAAAA #AAAAAA #AAAAAA; font-size: x-small; font-color: #666666;  }
</STYLE>
</head>

<body bgcolor="#FFFFFF" text="#333333">
<div id="HeadingLayer">
  <table id="HeaderTable" width="100%" border="0" cellpadding="8" cellspacing="0">
    <tr>
  	  <td bgcolor="#EBDEA9" width="100%" > 
        <p><font size="6" face="Georgia, Times New Roman, Times, serif" color="#000000"><b><a href="index.html" style="text-decoration: none"><font color="222222">proph<font face="Courier New, Courier, mono">It</font></font></a></b></font> 
          <br>
          <a href="http://prophit.westslopesoftware.com"><font color="#333333"> 
          prophIt.westslopesoftware.com<br>
    </font></a> </p>
	</td>
	</tr>
  </table>
</div>
<div id="topMenuLayer">
	
  <table cellspacing="0" cellpadding="4" width="100%">
    <tr>
			
      <td class="TopMenu"> Last Published: 02/14/2002 </td>
			<td>
				
        <div align="right"> <span class="TopMenu"><a href="index.html">prophIt</a> 
          | <a href="docs/index.html">Documentation</a> | <a href="download.html">Download</a> 
          </span> </div>
			
        <font face="Arial, Helvetica, sans-serif"></font></td>
		</tr>
	</table> 
</div>
<div id="MAIN">
<table id="main" border="0" cellspacing="0" cellpadding="8" width="100%">
	<tr valign="top">
		
    <td id="leftcol" width="20%"> 
        <div id="LeftMenuLayer"> 
          <p><span class="MenuHeader">prophIt</span><br>
            <span class="MenuItem"> - <a href="index.html">Home Page</a><br>
            - <a href="news.html">News and Status</a><br>
            - <a href="product-plan.html">Futures</a><br>
            - <a href="team.html">The Team</a><br>
            - <a href="download.html">Download</a></span><span class="MenuItem"><br>
            </span></p>
          <p><span class="MenuHeader">Documentation</span><br>
            <span class="MenuItem">- <a href="docs/index.html">Overview</a><br>
            &nbsp;&nbsp;&nbsp;- <a href="quick-start.html">Quick Start</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="docs/concepts.html">Concepts</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="docs/profiler-types.html">Profilers</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="docs/samples.html">Samples</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="docs/glossary.html">Glossary</a><br>
            - <a href="docs/faq.html">FAQ</a><br>
            </span> </p>
      </div>
		</td>
		<td>
			<div id="MainLayer">
			
			    <table name="MainTable" width="100%" bordercolor="#999999"  cellspacing="0" cellpadding="8" border="0">
					<tr>
						<td><div id="mainContentLayer">
						<!-- #BeginEditable "Main%20Content%20Region" --> 
                  <div class="header"><font size="4">New Feature Proposals</font></div>
                  <blockquote> This is a summary of our thoughts on product plan 
                    and direction. As with any aspect of our site, please <a href="mailto:info@prophit.westslopesoftware.com">send 
                    email</a> to us with your thoughts and opinions. </blockquote>
                  <p> 
                  <div class="header">Contents</div>
                  <blockquote> <b>Recently Implemented in Beta-2:</b> 
                    <ul>
                    <li><a href="#intelligent_labeling">Intelligent labeling</a></li>
                    <li><a href="#wire_frame">Wire-frame mode</a></li>
                    <li><a href="#improve_depth_slider">Improve depth slider</a></li>
                    <li><a href="#selection_feedback">Enhanced selection feedback</a></li>
					<li><a href="#bottom_up">Bottom-up functional view</a></li>				  
				  </ul>
				  <b>Planned For Future Releases:</b>
				  <ul>
				  	<li><a href="#ant_task">Integration with Ant tasks</a></li>
                    <li><a href="#time_threshold">Set time threshold</a></li>
                    <li><a href="#new_coloring">New coloring options</a></li>
                    <li><a href="#enhanced_searching">Enhanced searching</a></li>
                  	<li><a href="#compact_data_format">Compact call graph data format</a></li>
                  	<li><a href="#recursion_collapse">Collapse recursive functions</a></li>
                  	<li><a href="#profile_comparison">Profile comparison</a></li>
                  	<li><a href="#python_loader">Python profile loader</a></li>
                  	<li><a href="#perl_loader">Perl profile loader</a></li>
                  	<li><a href="#haskell_loader">Haskell profile loader</a></li>
                  </ul>
                  </blockquote>
				  <a name="bottom_up"><div class="header">Bottom-up View of the Tower Diagram</div>
                  </a> 
				  <blockquote>
					Often times a function is efficient, but is called or used in an inefficient manner.  It becomes difficult to
					optimize an extra 10% performance out of the function, but it might be easier to cause the function to be called 
					only half as many times.  Thanks to a suggestion from Owen Jones, we have added a feature that takes a selected function 
					and re-orients the tower diagram to focus on the calls to that function and who is calling it.  This helps identify 
					situations where a function is being called too often (for example, re-searching a data structure for an element each time through 
					a loop, rather than caching the value before the loop).  
				  </blockquote>

  				  <a name="ant_task"><div class="header">Ant Task Integration</div>
                  </a> 
				  <blockquote>
				  	We realize that many people are not even aware of the standard Java profiling tools - hprof, and prof.  In addition,
					hprof is a fairly complicated interface to master.  As a result, Kevin Gilpin has undertaken the task of building an
					open-source (and what could be standard) Ant task for collecting performance data from your application.  Details can be 
					found at <a href="http://antprof.sourceforge.net">http://antprof.sourceforge.net</a>.  This will enable us to further integrate
					prophIt into the development process by allowing us to leverage an Ant task to generate profile information for prophIt to view.
					We are currently examining further integration along these lines.  We use Ant to build our own projects, and highly recommend it. 
				  </blockquote>
				  <a name="intelligent_labeling"><div class="header">Intelligent labeling of the 
                    tower diagram</div>
                  </a> 
				  <blockquote>
				  The typical capacity of person's short-term memory is 7 
                  items. Without labels, keeping track of which blocks in the 
                  tower diagram correspond to which functions can become unmanagable. 
                  The tower diagram UI can help solve this problem by intelligently 
                  labeling certain blocks. Labels can be grouped into 3 categories: 
                  <ol>
                    <li>Prominent blocks : These are blocks which stand out in 
                      the diagram. A block can be a prominent block if: 
                      <ul>
                        <li>It has unusually large inclusive time and its children 
                          are not rendered in the diagram</li>
                        <li>It has unusually large exclusive time</li>
                      </ul>
                    </li>
                    <li>Recently selected blocks : Blocks which have recently 
                      been selected with the mouse, or by navigating through the 
                      caller/callee tables</li>
                    <li>Hover-over blocks : When the user hovers over a block 
                      for a short period of time (approximately half a second), 
                      a label is added to the block </li>
                  </ol>
                  Within each category of block label, there can only be a fixed 
                  number of labeled blocks. The number of labeled blocks depends 
                  on the available real estate inside the tower diagram's canvas 
                  that is not taken up by the diagram itself or by the legend. 
                  Expanding the canvas by maximizing the ProphIt application creates 
                  a large amount of label space. If the ProphIt application window 
                  is small, very few labels will fit on the canvas. 
                  <p>For large prominent blocks, the labels could be written into 
                    the blocks themselves.</p>
				  </blockquote>

                  <a name="wire_frame"><div class="header">Wire-frame mode</div></a>
				  <blockquote>
                  When it is being rotated, the tower diagram currently renders 
                  as a wire frame (with highlights for selected and search-result 
                  blocks). This wire-frame mode is useful for being able to see 
                  all the way through the tower diagram (and thus the call graph). 
                  Wire-frame mode reveals information such as the complete set 
                  of visible selected and search-result blocks, whereas in solid 
                  mode one can only see the blocks which make up the outer perimiter 
                  of the tower diagram. 
                  <p> An option to manually switch to wire-frame mode when the 
                    diagram is not being rotated would allow the user to see all 
                    the way through it. Rendering the selected and search-result 
                    blocks as solid blocks while the rest of the diagram is in 
                    manual wire-frame mode would allow the user to examine and 
                    select blocks which would not be easy to find if the entire 
                    diagram was solid. Several designs are possible for implementing 
                    manual wire-frame mode: 
                  <ol>
                    <li>Wire-frame mode could be automatically entered when the 
                      user executes a search. Upon executing the search, all blocks 
                      which are not selected or search-results are rendered in 
                      wire-frame. Clicking on any of the remaining solid blocks 
                      makes that block the new selected block, as normal. 
                      <ul>
                        <li>How should wire-frame mode be turned off in this scenario? 
                          Automatically when the user selects one of the solid 
                          blocks? Or manually by using a checkbox or similar control?</li>
                        <li>Automatic enabling of wire-frame mode could use one 
                          of the controls described in options (2) and (3). Which 
                          one is more appropriate?</li>
                      </ul>
                    </li>
                    <li>Wire-frame mode is entered manually using a checkbox. 
                      The checkbox label is simply 'Wireframe'. If checked, all 
                      blocks which are not selected or search-results render as 
                      wireframe, and continue to do so until the checkbox is un-checked.</li>
                    <li>Wire-frame mode is entered manually using a combo box 
                      (dropdown list). The combo box options are: 
                      <ul>
                        <li>Off</li>
                        <li>Partial (renders selected and search-result blocks 
                          as solid)</li>
                        <li>On (all blocks are rendered as wireframe)</li>
                      </ul>
                    </li>
                  </ol>
				  
				  <p>If intelligent labeling is implemented, all of the blocks 
                    which render as solid in wire-frame mode can be labeled. </p>
					
                  </blockquote>

                  <a name="improve_depth_slider"><div class="header">Improve depth slider</div></a>
				  <p>
				  The maximum stack depth that the prophIt application will show by default is 15. This
				  can be increased by pressing the '+' key with the focus on the tower diagram, but there
				  are several problems with this feature:
				  </p>
				  <ol>
                    <li>It is not very well-documented</li>
                    <li>It is not intuitive</li>
                    <li>The application does not provide any indication of what 
                      the maximum depth of the call graph actually is</li>
                    <li>If there are fewer than 15 calls in the call graph subset 
                      displayed by the diagram, there is no indication that moving 
                      the depth slider higher will not show any more information</li>
                  </ol>
                  <p>It is possible to determine from the call graph what the 
                    maximum depth actually is. This maximum depth could be used 
                    to set the max value on the depth slider, and this max value 
                    could be adjusted as the user explores the tower diagram. 
                    For instance, if the deepest function has 30 functions in 
                    its call stack, the maximum depth is 30. </p>
                  <a name="time_threshold"><div class="header">Set time threshold</div></a>
				  <p> The tower diagram clips out any functions which take up 
                    less than a predetermined amount of time as a percentage of 
                    the diagram root call. This value is currently about 3 / W, 
                    where <code>W</code> equals the width of the tower diagram 
                    window. Allowing the user to set this threshold manually, 
                    or adjusting automatically it in a more intelligent manner 
                    would have some benefits:</p>
                  <ol>
                    <li>Functions which do not contribute significantly to the 
                      program time (at least in the current diagram) would be 
                      removed from the diagram. When the user first loads a profile, 
                      the threshold could be set to a high value to show a rough 
                      picture of the profile. At a later time, the threshold can 
                      be lowered to show more detail</li>
                    <li>If the threshold were raised as deeper stack depths are 
                      shown, the performance impact of showing a deeper stack 
                      could be mitigated</li>
                  </ol>
				  <a name="selection_feedback">
                  <div class="header">Enhanced selection feedback</div>
                  </a> 
                  <blockquote>
				  <p>When a block is selected by a mouse-click (a 'selected' block) 
                    or identified by a search (a 'search-result' block), thin 
                    lines similar to the ribbons on a present are drawn around 
                    the block to hilight it. This hilighting is not particularly 
                    prominent or visible. In order to enhance the visibility of 
                    these hilights, one or more of the following may be implemented:</p>
                  <ol>
                    <li>Bolder lines. The hilight lines are currently one-pixel-wide 
                      lines of a single color. The lines could be thickened, composed 
                      of contrasting colors, or rendered as dashes rather than 
                      solid lines.</li>
                    <li>Animated selection. When the hilights are initially drawn, 
                      some animation could be used to attract attention to them. 
                      For instance the lines could start out thick and gradually 
                      render as thinner and thiner. Or borders could be drawn 
                      around the blocks with dotted lines that slowly progress 
                      around the block's edges.</li>
                  </ol>
				  </blockquote>
                  <a name="new_coloring"> 
                  <div class="header">New coloring options</div>
                  </a> <blockquote>
                  <p>The coloring on the call graph currently shows the exclusive 
                    time of each block. New coloring algorithms could be used 
                    to present other information about the profile. For example:</p>
                  <ol>
                    <li>Total exclusive time. The block coloring could show the 
                      total exclusive time for the block's function call, rather 
                      than just the exclusive time of the block itself. This amounts 
                      to summing up the exclusive time across all blocks which 
                      are instances of the same function call.</li>
                    <li>Total inclusive time. Analagous to (1), but using inclusive 
                      rather than exclusive time.</li>
                    <li>'Most commonly used'. The block coloring could be determined 
                      by the number of places in the call graph that the block's 
                      function occurs. This would make it easy to identify functions 
                      which are called from many different places in the call 
                      graph, and thus may be contributing significantly to the 
                      program's time even if no single block is a prominent hotspot. 
                      This algorithm presents information similar to, but not 
                      identical to, a coloring based on total exclusive or inclusive 
                      time. </li>
                  </ol>
				  </blockquote>
                  <a name="enhanced_searching"> 
                  <div class="header">Enhanced searching</div>
                  </a> <blockquote>
                  <p>The prophIt search bar currently only searches by function 
                    call name. The ability to search based on additional fields 
                    such as inclusive time or exclusive time (as percentages of 
                    total program time), to display the results in tabular form, 
                    and to sort the results based on some timing data, would greatly 
                    enhance the search feature. For instance, this would provide 
                    a straightforward mechanism to display a table of hot-spots, 
                    sorted in descending order of exclusive time.</p>
                  <p>It is common for profilers to show a bar chart that goes 
                    along with this hot-spot view. prophIt could show the search 
                    data with this enhancement as well.</p>
					</blockquote>
                  <a name="compact_data_format"> 
                  <div class="header">Compact call graph data format</div>
                  </a> 
				  <blockquote>
				  prophIt should have its own compact call graph data format 
                  which it can use to distribute profile data in a lightweight 
                  fashion. This format can be used for distributing additional 
                  samples, for storing interesting call graphs on the server, 
                  and for caching call graphs on the users' client machines. 
                  <p> 
                  </blockquote>
				  <a name="recursion_collapse"> 
                  <div class="header">Collapse recursive functions</div>
                  </a>
				  <blockquote> Recursive functions can be hard to profile, because each 
                  instance of the function call has its own caller and callee 
                  time breakdown. Frequently it would be more useful to be able 
                  to combine the callers and callees for all the recursive call 
                  instances into one call. This gives a more accurate picture 
                  of the time taken by the recursive function and its callees. 
                  <p> </blockquote>
                  <a name="profile_comparison"> 
                  <div class="header">Profile Comparison</div>
                  </a> 
				  <blockquote>Profiling is part of an iterative process in which a program 
                  is analyzed, then improved, then analyzed again. It would be 
                  very useful to be able to compare profile data gathered on a 
                  program before and after a set of changes have been made. prophIt 
                  can use a new block-coloring scheme to display the differences 
                  between the two profiles. A tower diagram of the new profile 
                  can be rendered as usual. The color of each block which has 
                  an identical counterpart (a function call with an identical 
                  stack) in the old profile can be determined by the ratio of 
                  the new time to the old time. In this way, functions which were 
                  substantially speed up or slowed down can be quickly identified. 
                  Functions which are added to or dropped from the old profile 
                  can also be highlighted using distinctive colors. 
				  </blockquote>

 				  <a name="python_loader"><div class="header">Python profile loader</div></a>
				  <blockquote>
				  Python has a built-in <a href="http://www.python.org/doc/current/lib/profile.html">profiler</a>
				  which capture statistics as a Python program runs and saves them to an in-memory data structure.
				  This profile data can be dumped to a file using <code>profile.Profile.dump_stats()</code> and re-loaded using
				  <code>pstats.Stats.load_stats()</code>
				  <p> A profile loader could be implemented for prophIt to display 
                    the Python profile data. This loader could use the <code>Stats</code> 
                    Python class to load the data, then pull it into the prophIt 
                    data model. The full stack information is not preserved by 
                    the Python profiler; in essence the profile would look like 
                    a <code>-prof</code> profile, or an <code>hprof</code> profile 
                    with <i>depth=2</i>. Full stack information could potentially 
                    be obtained by writing a <code>Profiler</code> subclass. This 
                    is theoretically possible but the procedure is not well documented. 
				  </blockquote>

 				  <a name="perl_loader"><div class="header">Perl profile loader</div></a>
				  <blockquote>
				  Perl has a built-in profiler called <a href="http://www.perldoc.com/perl5.6/lib/Devel/DProf.html">Devel::DProf</a>.
				  This profiler dumps out profiling data to yet another text file format which prophIt could be adapted to read.
				  </blockquote>
				  
 				  <a name="haskell_loader"><div class="header">Haskell profile loader</div></a>
                  <blockquote>The functional language Haskell 
                    also has a <a href="http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html">built-in 
                    profiler</a> for which a prophIt profile loader could potentially 
                    be implemented.
                  <p>The file format looks quite simple, rather similar to the 
                    <code>java -prof</code> output. While the execution model 
                    of Haskell is very different than any imperitive language, 
                    the profile data still breaks down to the form of a call stack.</p></blockquote>
                  <!-- #EndEditable -->
						</div></td>
					</tr>
				</table>
				<table width="100%" border="0" cellspacing="0" cellpadding="0">
				  <tr>
					
              <td></td>
				  </tr>
				</table>
			</div>
		
		</td>
	</tr>
</table>
</div>
<div id="footer">
<table border="0" width="100%">
<tr>
      <td> 
        <div id="wsswFooter" align="bottom"> 
          <p class="MenuItem"><a href="http://www.westslopesoftware.com" target=_blank><img src="assets/wsswLogo.jpg" width="673" height="99" border="0"></a> 
          </p>
        </div>
</td>
      <td align="right"> 
        <div id="ironworksFooter" align="bottom"> 
        <p class="MenuItem"><font size="+1"><a href="http://www.ironworks.cc">Ironworks.cc</a></font></p>
      </div>
</td>
</tr>
</table>
<p>&nbsp;</p>
</div></body>
<!-- #EndTemplate --></html>
